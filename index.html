<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Emulation for Course Scheduling - Joel Santos CSC375</title>
    <style>
        .container {
            text-align: center;
            margin: 0 auto;
            max-width: 800px;
        }
        img {
            max-width: 100%;
            height: auto;
        }
        .explanation {
            text-align: left;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Benchmark Results for Add, Get, Update and Remove</h1>
        <div>
            <h2>Benchmark Add</h2>
            <img src="https://github.com/NichtSylph/ParallelBenchmark/blob/master/addPlot.jpg?raw=true" alt="Benchmark Result Plot Add">
            <h2>Benchmark Get</h2>
            <img src="https://github.com/NichtSylph/ParallelBenchmark/blob/master/getPlot.jpg?raw=true" alt="Benchmark Result Plot Get">
            <h2>Benchmark Update</h2>
            <img src="https://github.com/NichtSylph/ParallelBenchmark/blob/master/removePlot.jpg?raw=true" alt="Benchmark Result Plot Update">
            <h2>Benchmark Remove</h2>
            <img src="https://github.com/NichtSylph/ParallelBenchmark/blob/master/updatePlot.jpg?raw=true" alt="Benchmark Result Plot Remove">
        </div>
        <div class="explanation">
            <h2>Performance Analysis</h2>
            <p>
                The benchmark results illustrate the strengths and trade-offs between Custom Concurrency and Standard Concurrency mechanisms across various operations. The Custom Concurrency strategy, employing ReentrantReadWriteLock, optimizes for read performance by allowing multiple concurrent reads, which is advantageous for workloads where read operations predominate. However, it introduces overhead for write operations due to the necessity of acquiring and releasing the write lock, albeit allowing more concurrency than exclusive locks.
            </p>
            <p>
                On the other hand, the Standard Concurrency approach, utilizing ConcurrentHashMap, provides consistent performance across both read and write operations. Its segment-locking mechanism minimizes contention during concurrent writes, making it well-suited for high-throughput environments where write operations are frequent and need to be performed atomically across multiple threads.
            </p>
            <p>
                The observed results indicate that while Custom Concurrency can offer benefits for read-dominated scenarios by reducing read contention, Standard Concurrency remains a strong contender for balanced or write-heavy workloads due to its efficient handling of concurrent updates. The choice between the two should be guided by the specific needs of the application, considering the proportion of read versus write operations and the desired concurrency level.
            </p>
        </div>        
    </div>
</body>
</html>
